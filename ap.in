#!/usr/bin/lua

aports = require("aports")
lfs = require("lfs")

local db

local function build_is_outdated(pkg)
	local apk_attr = lfs.attributes(aports.get_apk_file_path(pkg))
	local apkbuild_attr = lfs.attributes(pkg.dir.."/APKBUILD")
	if apk_attr == nil then
		return true
	end
	return os.difftime(apk_attr.modification, apkbuild_attr.modification) < 0
end

local function build_is_missing(pkg)
	return lfs.attributes(aports.get_apk_file_path(pkg)) == nil
end
	
-- subcommands -----------------------
subcmd = {}
subcmd.revdep = {
	desc = "Print reverse dependencies",
	usage = "PKG...",
	run = function(opts)
		local i
		for i = 1, #opts do
			db:foreach_revdep(opts[i], function (k,p)
				print(p.pkgname)
			end)
		end
	end
}

subcmd.list = {
	desc = "Print all packages built from aports tree",
	usage = "",
	run = function()
		db:foreach(function (k)
			print(k)
		end)
	end
}

subcmd.recursdeps = {
	desc = "Recursively print all make dependencies for given packages",
	usage = "PKG...",
	run = function (opts)
		for i = 1, #opts do
			db:recurs_until(opts[i], function(pn)
				print(pn)
			end)
		end
	end
}

subcmd.builddirs = {
	desc = "Print the build dirs for given packages in build order",
	usage = "PKG...",
	run = function(opts)
		local i, p, _
		local visited = {}
		local to_print = {}
		for i = 1, #opts do
			db:foreach_pkg(opts[i], function(_, p)
				to_print[p.dir] = true
			end)
		end
		for i = 1, #opts do
			db:recurs_until(opts[i], function(pn)
				local j,p
				db:foreach_pkg(pn, function(j, p)
					if to_print[p.dir] then
						print(p.dir)
						to_print[p.dir] = nil
					end
				end)	
			end)
		end
	end
}

subcmd.sources = {
	desc = "List sources",
	usage = "PKG...",
	run = function(opts)
		local i, p, _
		for i = 1, #opts do
			db:foreach_pkg(opts[i], function(_, p)
				aports.foreach_remote_source(p, function(url)
					print(p.pkgname, p.pkgver, string.gsub(url, p.pkgver, "$VERSION"))
				end)
			end)
		end
	end
}

subcmd["rebuild-list"] = {
	desc = "List packages that can/should be rebuilt",
	usage = "",
	run = function()
		local outdated = {}
		db:foreach(function(k)
			db:foreach_pkg(k, function(_, p)
				if build_is_outdated(p) then
					table.insert(outdated, p.pkgname)
				end
			end)
		end)
		-- print build dirs in build sort order
		subcmd.builddirs.run(outdated)
	end
}

subcmd["build-list"] = {
	desc = "List packages that is not built",
	usage = "",
	run = function()
		local missing = {}
		db:foreach(function(k)
			db:foreach_pkg(k, function(_, p)
				if build_is_missing(p) then
					table.insert(missing, p.pkgname)
				end
			end)
		end)
		-- print build dirs in build sort order
		subcmd.builddirs.run(missing)
	end
}

subcmd["list-apks"] = {
	desc = "List all apk files",
	usage = "",
	run = function()
		db:foreach(function(k)
			db:foreach_pkg(k, function(_, p)
				print(aports.get_apk_filename(p))
			end)
		end)
	end
}

function print_usage()
	io.write("usage: ap -d <DIR> SUBCOMMAND [options]\n\nSubcommands are:\n")
	local k,v
	for k in pairs(subcmd) do
		print("  "..k)
	end
end

-- those should be read from some config file
repodirs = {} 


-- parse args
i = 1
opts = {}
help = false
while i <= #arg do
	if arg[i] == "-d" then
		i = i + 1
		repodirs[#repodirs + 1] = arg[i]
	elseif arg[i] == "-h" then
		help = true
	else
		opts[#opts + 1] = arg[i]
	end
	i = i + 1
end


cmd = table.remove(opts, 1)

if cmd == nil then
	print_usage()
	-- usage
	return
end

if #repodirs == 0 then
	if lfs.attributes("APKBUILD") then
		repodirs[1] = string.gsub(lfs.currentdir(), "(.*)/.*", "%1")
	else
		repodirs[1] = lfs.currentdir()
	end
end

if subcmd[cmd] and type(subcmd[cmd].run) == "function" then
	db = aports.new(repodirs)
	loadtime = os.clock()
	subcmd[cmd].run(opts)
	runtime = os.clock() - loadtime
--	io.stderr:write("db load time = "..tostring(loadtime).."\n")
--	io.stderr:write("cmd run time = "..tostring(runtime).."\n")
else
	io.stderr:write(cmd..": invalid subcommand\n")
end

